# ---
# apiVersion: external-secrets.io/v1
# kind: SecretStore
# metadata:
#   name: serving-secret-backend
# spec:
#   provider:
#     vault:
#       server: "http://hashicorp-vault-internal:8200"
#       path: "kube-system/serving-certs"
#       version: "v2"
#       auth:
#         tokenSecretRef:
#           name: "vault-token"
#           key: "token"
---
# yaml-language-server: $schema=https://kubernetes-schemas.pages.dev/external-secrets.io/pushsecret_v1alpha1.json
apiVersion: external-secrets.io/v1alpha1
kind: PushSecret
metadata:
  name: rke2-serving-prod
spec:
  secretStoreRefs:
    - name: vault-backend-cross-namespaces-secret
      kind: ClusterSecretStore
  selector:
    secret:
      name: rke2-serving
  template:
    engineVersion: v2
    data:
      tls.crt: '{{ index . "tls.crt"}}'
      tls.key: '{{ index . "tls.key"}}'
  data:
    - match:
        secretKey: &key tls.crt
        remoteRef:
          remoteKey: kube-system/serving-certs/rke2-serving-prod
          property: *key
    - match:
        secretKey: &key tls.key
        remoteRef:
          remoteKey: kube-system/serving-certs/rke2-serving-prod
          property: *key

# ---
# apiVersion: external-secrets.io/v1alpha1
# kind: ClusterPushSecret
# metadata:
#   name: "rke2-serving-prod"
# spec:
#   pushSecretName: "rke2-serving-prod"

#   # This is a list of basic label selector to select the namespaces to deploy PushSecrets to.
#   # you can read more about them here https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#resources-that-support-set-based-requirements
#   # The list is OR'd together, so if any of the namespaceSelectors match the namespace,
#   # the ExternalSecret will be deployed to that namespace.
#   # namespaceSelectors:
#   # - matchLabels:
#   #     cool: label

#   # How often the ClusterPushSecret should reconcile itself
#   # This will decide how often to check and make sure that the PushSecrets exist in the matching namespaces
#   refreshTime: "1m" # change to like 15 min

#   # This is the spec of the PushSecrets to be created
#   # The content of this was taken from our PushSecret example
#   pushSecretSpec:
#     updatePolicy: Replace # Policy to overwrite existing secrets in the provider on sync
#     deletionPolicy: Delete # the provider' secret will be deleted if the PushSecret is deleted
#     refreshInterval: 1h # Refresh interval for which push secret will reconcile
#     secretStoreRefs: # A list of secret stores to push secrets to
#       - name: aws-parameterstore
#         kind: SecretStore
#     selector:
#       secret:
#         name: source-secret # Source Kubernetes secret to be pushed
#       # Alternatively, you can point to a generator that produces values to be pushed
#       # generatorRef:
#       #   apiVersion: external-secrets.io/v1alpha1
#       #   kind: ECRAuthorizationToken
#       #   name: prod-registry-credentials
#     template:
#       engineVersion: v2
#       data:
#         tls.crt: '{{ index . "tls.crt"}}'
#         tls.key: '{{ index . "tls.key"}}'
#     data:
#       - match:
#           secretKey: &key tls.crt
#           remoteRef:
#             remoteKey: icylair-com-all-prod
#             property: *key
#       - match:
#           secretKey: &key tls.key
#           remoteRef:
#             remoteKey: icylair-com-all-prod
#             property: *key
